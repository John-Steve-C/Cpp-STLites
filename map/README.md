# STLite-Map

## 实现细节

* 算法要求：
  * **B班**：AVL AA 红黑树三选一
  * **A班**：红黑树

`sjtu::map`的最终提交仅需要提交`map.hpp`的内容。具体细节可以查看下发的`map.hpp`框架。

可能需要注意的细节：

- 你的程序将会受到一定程度的鲁棒性检测
- 提供了类似`type_traits`的`toy_traits_test`的测试（在`data`文件夹中），对`type_traits`感兴趣的同学可以试着完成一下。

## 分数构成

OJ测试部分占比：80%，code review部分占比：20% (16%基础问题+4%bonus)

以基础的二叉搜索树完成此题，最终得分为`0.4*以上得分`。

以算法要求外的方法完成此题，最终得分为`0.7*以上得分`。

bonus可以是对容器某个行为的优化，type_traits相关应用（学习、完成`test`、应用等）或其他有创意的想法。在`code review`时展示即可。

如果在CR时，发现有任何违规行为（包括但不限于使用其它头文件、使用非常规方法通过测试点），你最终的得分都有可能为 $0$ 分。

## 截止日期

4月9日（第七周周六）23:00前

---

## 编程记录

- 要考虑迭代器失效的问题？
- 换一种写法，先写好红黑树类，再新定义一个map类（其中封装好红黑树），这样写比较好。
  
  之前写 `vector` 和 `priority_queue` 的时候，都是直接把线性表和大根堆当成了目标类，不具有普适性。
- 要尽量采用统一的命名规范，比如说变量类型(全部大写/首字母大写)、变量名(每个单词首字母大写)、函数名(小写 + 下划线)
- 颜色的修改在旋转操作中实现

  如果要通过指针来修改其指向的变量，指针那就没有必要引用传递?
- 记得要用给定的 `Compare` 函数来比较大小 

2022.3.27

### To do list

- [ ] 重写 `RedBlackTree` 类
- [x] 迭代器
- [ ] `exception` 异常处理

---

胡思乱想

- 昨天写数学和物理，没有写代码
- 今天先把 `remove` 写完，据说书上的代码是错的。
- ~~我一部分是抄书的，一部分又是自己瞎jb写的，肯定会出大问题~~ 
- 赶紧把迭代器写好，开始调试。
- 感觉 `bug` 非常多啊...还在写就感觉不对了
- 偷懒小技巧：`NODE` 是红黑树的内嵌类，`map` 无法访问，所以可以用 `auto` 代替 `NODE`？或者把 `NODE` 放到外面,不要用内置类
- 还是对红黑树的实现，不是很理解
- 大致完成了 `map` 和 `iterator` 类，实在不行，还有最后的方法：参考吴老师的代码...
- 实现思路有问题,为什么不把迭代器的 `++` 放到红黑树中实现呢?
- 还是好菜啊......直接参考周老师的代码了...

---
### 重要内容

#### `NODE`

- `iter++`指的是访问下一个比key大的位置,要在树上寻找,所以也要保存一个指向本身的 `*id` 指针

  而且 `NODE` 必须写成三叉链表，还要记录一个父节点
- 其实按照翁阿姨的写法也不是不行，但是需要对 `NODE` 重载等于号,构造函数,析构函数

  助教给的模板一般都是 **不完整** 的啊
- 似乎手写的 `Key` 类型也没有重载 `==` ？ 需要用 `Compare()` 来判断？
- `NODE` 中存储的应该都是指针，因为复合的 `value_type` 可能太大，不能按照翁阿姨的板子来写。

  而且复制构造函数 不能直接复制 `NODE` 的左右儿子，只能赋值为 `nullptr`？
- 因为给定的 `T` 有默认构造函数，但是 `Key` 没有，所以对于复合的 `value_type` 就没有构造函数？但是在给定的 `utility.hpp` 中有 `value_type` 的复制构造函数
  - 可以写成 `malloc` 
  - 也可以只写复制构造，默认构造就用 `default`（就是 `nullptr`）
- 我原本写的复制也有问题，不应该对指针复制
- 复制构造又写错了,应该是 `*(other.data)`

#### `RedBlackTree`

- 因为一般在 STL 中，要求 `end` 指向的是最后一个位置的后面。又因为红黑树的节点不是连续的，所以要设置一个 `end = nullptr` 节点
- 是否要把 `RedBlackTree` 写成 `map`的内置类？
- 不能简单地把 `end_node` 设置为 `nullptr`，因为任意两个空指针是相等的，不能作为判断的标准

  对应地，要把 `iterator` 指的改成 `NODE`
- 修改为三叉链表后，旋转、插入、删除等等都要修改
- 发现我原本写的旋转操作是没问题的，只是稍显复杂，而且没有修改父指针
- 细节真的多。当指针采用值传递时，会新声明一个指针变量y，设原本变量为x
  - 可以通过修改 `*y` 来修改 `*x`
  - 但是修改 `y` 不能修改 `x` 本身的值，如果要改就必须引用传递
- 问题最大的还是 `remove` ，翁阿姨写的是直接把 `NODE` 赋值过去，但是正常的写法应该是改 指针的连接和颜色，而不是数据。

  所以 `remove` 就要改很多地方
- 虽然旋转操作中会改变颜色，但是为了保证正确性，还是在`adjust`中，旋转后重新上色

#### `iterator`

- 迭代器指向的元素应该是 整个 `NODE`，还要保存指向原 `map` 的指针

  否则在 `++` 时还需要返回到树上，先 `find` 才能修改，时间复杂度爆炸
- 模板要实例化
- 对空指针和`end` 迭代器不能解引用 `*`
- 重载等于号，要记得先把原对象析构，在进行复制构造

#### `map`

- 对 [] 和 const [] 的要求竟然不一样...

---

### 调试

1. discards qualifiers，表示有修改 `const` 变量的操作
  
    问题在于，map的复制构造函数，要用列表来实现；而且 `front` 和 `back` 应当声明为 `const`

2. `utility.hpp` 中没有 `make_pair` 函数
3. call of overloaded ‘RedBlackTree()’ is ambiguous

    红黑树类中，定义了一个只有一个缺省参数的构造函数，会与默认构造函数混淆

4. `Segmentation fault` -> 红黑树的默认构造函数，root应该设置为空指针，然后在 find 时做特判

    也就是要避免对空指针进行解引用

5. 现在是会访问到空指针，还是 `remove` 的问题，但是我已经和周老师的代码手动对比了，感觉没问题？
6. `LR`，`remove_adjust` 中有好多细节写错了
7. `remove` 中的 `left/right` 写反了...
8. 原本以为析构函数写错了，最后在周老师的帮助下，发现是`remove` 中的一个赋值写成了 `==`

    还是要多学一点调试技巧！除了输出信息，还可以手写一组小数据来测试！

9. `make_empty` 的参数 `NODE*` 必须引用传递，因为`delete` 之后会有 `t=nullptr`的操作
10. `insert`要长度加一
11. 后缀`++`的重载写错了，应该返回的是临时变量，然后对原变量执行 ++ 操作
12. 求`begin`函数，随着删除操作，最终begin应该与end重合，也就是要对begin的 `front` 函数进行特判
13. `const_iterator` 对应的是 `cend`
14. 复制构造一开始，也要让`root = nullptr`
15. 终于发现为什么会T了，因为 `begin` 的查询花费太多时间，所以直接把最小值的指针保存下来就可以了

    只有`insert`,`delete`,构造,`make_empty`等函数需要修改两个指针，还有`back`等需要加上特判空指针的情况

16. 最后的2个重要的特判，一定要先判断 **map是否为空** ，再去判断 `head` / `end_node` 的问题  
    ```cpp
	iterator begin() {
        if (mp.root == nullptr) return iterator(mp.end_node, this);//判断是否为空
        else return iterator(mp.head, this);
    }
    
    iterator &operator--() {
                if (id->mp.root == nullptr) throw invalid_iterator(); //判断map空
                if (p == id->mp.head || p == nullptr) throw invalid_iterator();
                if (p == id->mp.end_node) p = id->mp.back();
                else if (p->left) {
                    p = p->left;
                    while (p->right) p = p->right;
                } else {
                    while (p->fa && p->fa->left == p) p = p->fa;
                    p = p->fa;
                }
                return *this;
            }
    ```

---

## Code Review

- 删除，举例子模拟实现（结果考我的是insert，口胡了半天发现错了.......）
- 迭代器的平均复杂度 O(1)，按dfs遍历一棵树，然后求平均，
  - 最坏是log，能否优化到 O(1)？用链表额外存储
- 没写`type_traits`的优化
- 